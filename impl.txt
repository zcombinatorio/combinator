Complete Bookbuilding Implementation Plan

  Overview

  New bookbuilding system with open bidding mechanism. Users submit bids ($ amount + max FDV), founder chooses clearing valuation, qualifying bids get pro-rata allocation with vesting.

  Token Distribution:
  - T tokens allocated to bookbuilding participants (vested)
  - 0.25T tokens to AMM pool
  - Remaining tokens to treasury (protocol balance - 1.25T)

  Fund Distribution:
  - 0.25R to AMM pool
  - 0.75R to treasury

  ---

  FULL MECHANISM SPECIFICATION

  Initial Parameters:
  - Total supply: S tokens (configurable, e.g. 1B)
  - Liquidity allocation: 25% of raise (hardcoded)

  Phase 1: Bookbuilding
  - Users submit public bids: ($ amount, max acceptable FDV)
  - Bids are withdrawable anytime before close
  - Close time is blind (unknown to participants)

  Phase 2: Founder Decision (at blind close)
  - Founder chooses one parameter: Clearing FDV (V)
  - All other parameters derive automatically:
    * Price per token:        P = V / S (where S = token supply)
    * Total $ raised:         R = Σ(bids where max_FDV ≥ V)
    * Tokens sold (bookbuilding):  T = R / P = (R × S) / V
    * $ to AMM liquidity:     0.25R
    * $ to treasury:          0.75R
    * Tokens in AMM:          0.25T = (0.25 × R × S) / V
    * Tokens to treasury:     (Protocol balance - 1.25T)

  Phase 3: AMM Launch
  - AMM seeded with: 0.25R dollars + 0.25T tokens
  - AMM starting price: (0.25R) / (0.25T) = R/T = P ✓ (matches bookbuilding)
  - Public trading begins

  Token Distribution at Launch:
  - Bookbuilding buyers: T (vested)
  - AMM pool: 0.25T
  - Treasury: (Protocol balance - 1.25T)

  Key Properties:
  ✓ Valuation certainty (bidders protected by max_FDV)
  ✓ Participation certainty (all qualifying bids filled 100%)
  ✓ No clustering/gaming (blind close)
  ✓ Price continuity (AMM = bookbuilding price)
  ✓ Self-limiting (founder's dilution prevents overpricing)

  ---
  Phase 0: Token Creation (Run Before Bookbuilding)

  IMPORTANT: Tokens must be created BEFORE creating a bookbuilding.
  One token can be used for multiple bookbuildings (repeated fundraises).
  Founder transfers desired amount to protocol wallet before each launch.

  Script: ui/scripts/create-bookbuilding-token.ts

  Usage:
  1. Edit TOKEN_CONFIG in the script:
     - name: 'MyToken'
     - symbol: 'MTK'
     - supply: 1_000_000_000  (1 billion)
     - decimals: 6
     - caEnding: 'ABC' (optional)

  2. Ensure environment variables are set:
     - PROTOCOL_MINT_AUTHORITY_PRIVATE_KEY
     - RPC_URL

  3. Run: tsx scripts/create-bookbuilding-token.ts

  4. Save the output JSON file (contains token address and metadata)

  5. Use the token address when creating a bookbuilding

  This script:
  - Generates token keypair (with optional vanity ending)
  - Creates mint account
  - Mints entire supply to protocol wallet
  - Saves token info to scripts/tokens/

  ---
  Phase 1: Database Schema Creation

  1.1 Create bookbuildings Table

  CREATE TABLE bookbuildings (
    id SERIAL PRIMARY KEY,
    token_address TEXT NOT NULL UNIQUE,
    token_supply BIGINT NOT NULL,
    token_decimals INT NOT NULL,
    creator_wallet TEXT NOT NULL,
    contribution_token_mint TEXT NOT NULL,
    contribution_token_decimals INT NOT NULL,
    vesting_duration_seconds BIGINT NOT NULL,
    vesting_cliff_seconds BIGINT DEFAULT 0,
    clearing_fdv BIGINT,
    amm_pool_address TEXT,
    escrow_public_key TEXT NOT NULL,
    escrow_priv_key TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending',  -- 'pending' | 'launched'
    created_at TIMESTAMP DEFAULT NOW(),
    launched_at TIMESTAMP
  );

  COMMENT ON COLUMN bookbuildings.token_address IS 'Token mint address (created beforehand by protocol)';
  COMMENT ON COLUMN bookbuildings.token_supply IS 'Total token supply (e.g., 1000000000 for 1B)';
  COMMENT ON COLUMN bookbuildings.escrow_priv_key IS 'Encrypted escrow private key (for contribution tokens)';

  CREATE INDEX idx_bookbuildings_token_address ON bookbuildings(token_address);
  CREATE INDEX idx_bookbuildings_creator_wallet ON bookbuildings(creator_wallet);
  CREATE INDEX idx_bookbuildings_status ON bookbuildings(status);

  1.2 Create bookbuilding_bids Table

  CREATE TABLE bookbuilding_bids (
    id SERIAL PRIMARY KEY,
    bookbuilding_id INT NOT NULL REFERENCES bookbuildings(id) ON DELETE CASCADE,
    user_wallet TEXT NOT NULL,
    bid_amount BIGINT NOT NULL,  -- Contribution amount in token smallest units
    max_fdv BIGINT NOT NULL,
    transaction_signature TEXT NOT NULL UNIQUE,
    withdrawn BOOLEAN DEFAULT false,
    withdrawal_signature TEXT,
    qualifying BOOLEAN,
    tokens_allocated BIGINT DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW()
  );

  COMMENT ON COLUMN bookbuilding_bids.bid_amount IS 'Contribution amount in token smallest units (not lamports)';

  CREATE INDEX idx_bookbuilding_bids_bookbuilding_id ON bookbuilding_bids(bookbuilding_id);
  CREATE INDEX idx_bookbuilding_bids_user_wallet ON bookbuilding_bids(user_wallet);
  CREATE INDEX idx_bookbuilding_bids_withdrawn ON bookbuilding_bids(withdrawn);
  CREATE INDEX idx_bookbuilding_bids_qualifying ON bookbuilding_bids(qualifying);

  1.3 Create bookbuilding_claims Table

  CREATE TABLE bookbuilding_claims (
    id SERIAL PRIMARY KEY,
    bookbuilding_id INT NOT NULL REFERENCES bookbuildings(id) ON DELETE CASCADE,
    user_wallet TEXT NOT NULL,
    tokens_allocated BIGINT NOT NULL,
    tokens_claimed BIGINT DEFAULT 0,
    vesting_start_at TIMESTAMP NOT NULL,
    last_claim_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(bookbuilding_id, user_wallet)
  );

  CREATE INDEX idx_bookbuilding_claims_bookbuilding_id ON bookbuilding_claims(bookbuilding_id);
  CREATE INDEX idx_bookbuilding_claims_user_wallet ON bookbuilding_claims(user_wallet);

  1.4 Migration Script

  File: ui/scripts/migrations/003_bookbuilding.sql

  ---
  Phase 2: Backend API Implementation

  2.1 Create Bookbuilding Endpoint

  File: ui/app/api/bookbuilding/route.ts

  // Request body interface
  interface CreateBookbuildingRequest {
    tokenAddress: string;               // NEW - existing token address (created by protocol)
    contributionTokenMint: string;      // Contribution token (e.g., USDC)
    vestingDurationSeconds: number;     // Vesting period
    vestingCliffSeconds?: number;       // Optional cliff
    creatorWallet: string;
    // ... other metadata fields
  }

  Updates:
  - Accept tokenAddress (token already created by protocol using create-bookbuilding-token.ts)
  - Verify token exists on-chain and fetch metadata
  - Fetch token supply and decimals from the mint
  - Generate escrow keypair (for holding contribution tokens)
  - Fetch contribution token decimals from chain:
    const mintInfo = await getMint(connection, new PublicKey(contributionTokenMint));
    const contributionTokenDecimals = mintInfo.decimals;
  - Validate contribution token exists and is valid
  - Store token address, supply, vesting parameters with fetched decimals
  - Return escrow public key

  Note: No need to check protocol wallet balance at creation time.
  This allows repeated bookbuildings for the same token.
  Balance validation happens at launch time instead.

  2.2 Submit Bid Endpoint

  File: ui/routes/bookbuilding.ts (new endpoint)

  POST /:tokenAddress/bids
  Body: {
    transactionSignature: string,
    maxFdv: string  // In same units as bid amount
  }

  Logic:
  1. Verify status = 'pending'
  2. Verify transaction on-chain using verifyBookbuildingTokenTransaction()
    - Check sender = user wallet
    - Check recipient = escrow
    - Check token mint = bookbuilding.contribution_token_mint
    - Extract bid_amount from transfer instruction
  3. Insert into bookbuilding_bids with max_fdv
  4. Return success

  Notes:
  - No minimum bid amount validation
  - Users can submit multiple bids (intentional for different price points)
  - Bid modification NOT allowed - users must withdraw and resubmit
  - User pays for creating any required ATAs (associated token accounts)

  2.3 Withdraw Bid Endpoint

  File: ui/routes/bookbuilding.ts (new endpoint)

  POST /:tokenAddress/bids/withdraw
  Body: {
    bidId: number,
    userPublicKey: string
  }

  Logic:
  1. Acquire bookbuilding lock (prevents race with launch)
     const releaseLock = await acquireBookbuildingLock(tokenAddress);
  2. Verify status = 'pending' (can't withdraw after launch)
  3. Fetch bid from DB, check ownership
  4. Check not already withdrawn
  5. Create refund transaction (escrow → user)
  6. Dual-signature pattern (user signs, server adds escrow sig)
  7. Mark bid as withdrawn
  8. Record withdrawal_signature
  9. Release lock in finally block

  2.4 Preview Calculations Endpoint

  File: ui/routes/bookbuilding.ts (new endpoint)

  GET /:tokenAddress/preview?fdv={V}

  Response:
  {
    clearingFdv: string,
    pricePerToken: string,        // P = V / token_supply
    totalRaised: string,           // R = Σ(bids where max_fdv >= V)
    tokensSold: string,            // T = (R × token_supply) / V
    liquidity: {
      dollars: string,             // 0.25R
      tokens: string               // 0.25T
    },
    treasury: {
      dollars: string,             // 0.75R
      tokens: string               // Protocol balance - 1.25T
    },
    qualifyingBids: Bid[],
    nonQualifyingBids: Bid[],
    totalBidsCount: number,
    qualifyingBidsCount: number
  }

  Logic:
  1. Fetch all non-withdrawn bids for bookbuilding
  2. Filter qualifying: !withdrawn AND max_fdv >= fdv
  3. Calculate R = sum of qualifying bid amounts
  4. Calculate all derived parameters using equations
  5. Return breakdown

  2.5 Launch Endpoint (Close + Launch Combined)

  File: ui/routes/bookbuilding.ts (new endpoint)

  POST /:tokenAddress/launch
  Body: {
    clearingFdv: string
  }

  Logic:
  1. Acquire bookbuilding lock (prevents race with withdrawals)
     const releaseLock = await acquireBookbuildingLock(tokenAddress);
  2. Validate:
    - Status = 'pending'
    - Creator wallet matches
    - Calculate R from qualifying bids (!withdrawn AND max_fdv >= clearing_fdv)
    - Error if R = 0 (no qualifying bids)
    - Calculate T = (R × token_supply) / clearing_fdv
    - CRITICAL VALIDATION: Ensure clearing_fdv >= (1.25 × R)
      * This ensures T <= 0.8 × token_supply, so 1.25T <= token_supply
      * Guarantees protocol wallet has enough tokens (validated separately in step 5)
      * Error message: "Clearing FDV too low. Minimum FDV: [1.25 × R]"
  3. CRITICAL: Verify escrow balance on-chain matches calculated R
    - Fetch escrow contribution token account balance
    - Compare with sum of non-withdrawn qualifying bids
    - Error if mismatch (prevents race conditions and fake bids)
  4. Update bids:
    - Mark qualifying bids (max_fdv >= clearing_fdv AND !withdrawn)
    - Calculate pro-rata allocations: tokens_allocated = (bid_amount / R) × T
    - Handle rounding (give remainder to largest bidder, not first)
  5. CRITICAL: Verify protocol wallet has enough tokens on-chain
    - Need 1.25T tokens total (0.25T pool + T vesting)
    - Plus whatever amount founder wants to keep in treasury
    - Fetch protocol token account balance
    - Error if balance < 1.25T

  const protocolTokenAccount = await getAssociatedTokenAddress(
    new PublicKey(bookbuilding.token_address),
    PROTOCOL_WALLET
  );
  const protocolBalance = await connection.getTokenAccountBalance(protocolTokenAccount);
  const requiredAmount = T.muln(125).divn(100); // 1.25T

  if (new BN(protocolBalance.value.amount).lt(requiredAmount)) {
    throw new Error(`Insufficient protocol balance. Need ${requiredAmount.toString()}, have ${protocolBalance.value.amount}`);
  }

  6. Transfer tokens from protocol to escrow for pool:
    - Token already exists (created beforehand by protocol using create-bookbuilding-token.ts)
    - Transfer 0.25T from protocol → escrow (so escrow can contribute to pool)

  const protocolTokenAccount = await getAssociatedTokenAddress(
    new PublicKey(bookbuilding.token_address),
    PROTOCOL_WALLET
  );
  const escrowTokenAccount = await getOrCreateAssociatedTokenAddress(
    new PublicKey(bookbuilding.token_address),
    escrowKeypair.publicKey
  );

  // Transfer 0.25T to escrow for pool creation
  const transferToEscrowTx = new Transaction();
  transferToEscrowTx.add(
    createTransferInstruction(
      protocolTokenAccount,
      escrowTokenAccount,
      PROTOCOL_WALLET,
      baseAmountForPool.toNumber()  // 0.25T
    )
  );
  await sendAndConfirmTransaction(connection, transferToEscrowTx, [PROTOCOL_WALLET_KEYPAIR]);

  6. Create Meteora CP-AMM pool (separate transaction):
  import { createBookbuildingCPAMMPool } from '@/lib/meteoraCpAmmService';

  // Calculate amounts for AMM pool (25% each)
  const baseAmountForPool = T.muln(25).divn(100);  // 0.25T
  const quoteAmountForPool = R.muln(25).divn(100); // 0.25R

  // Create pool WITH initial liquidity in ONE transaction
  // This handles both pool creation AND adding 0.25T + 0.25R automatically
  const { tx: createPoolTx, pool: poolAddress } = await createBookbuildingCPAMMPool({
    connection,
    baseMint: new PublicKey(baseMint),
    quoteMint: new PublicKey(bookbuilding.contribution_token_mint),
    baseAmount: baseAmountForPool,   // 0.25T tokens
    quoteAmount: quoteAmountForPool, // 0.25R funds
    creator: TREASURY_ADDRESS,
    payer: escrowKeypair.publicKey,
    escrowKeypair: escrowKeypair
  });

  // Send pool creation transaction
  const poolCreationSignature = await connection.sendTransaction(createPoolTx, { skipPreflight: false });
  await connection.confirmTransaction(poolCreationSignature, 'confirmed');

  7. Distribution Transaction (separate from pool creation):
  Transfer tokens to escrow for vesting and treasury:

  const distributionTx = new Transaction();

  // Transfer T tokens from protocol to escrow (for vesting claims)
  distributionTx.add(
    createTransferInstruction(
      protocolTokenAccount,
      escrowBaseAta,
      PROTOCOL_WALLET,
      T.toNumber()
    )
  );

  // Transfer remaining tokens to treasury
  // Treasury gets: (protocol balance) - 0.25T (already sent to escrow) - T (just sent above)
  // Which equals: (protocol balance) - 1.25T
  const protocolBalanceAfterEscrowTransfers = new BN(protocolBalance.value.amount)
    .sub(baseAmountForPool)  // Already transferred to escrow for pool
    .sub(T);                  // Just transferred above

  if (protocolBalanceAfterEscrowTransfers.gt(new BN(0))) {
    distributionTx.add(
      createTransferInstruction(
        protocolTokenAccount,
        treasuryBaseAta,
        PROTOCOL_WALLET,
        protocolBalanceAfterEscrowTransfers.toNumber()
      )
    );
  }

  // Transfer 0.75R from escrow to treasury (contribution tokens)
  const treasuryQuoteAmount = R.muln(75).divn(100);
  distributionTx.add(
    createTransferInstruction(
      escrowQuoteAta,
      treasuryQuoteAta,
      escrowKeypair.publicKey,
      treasuryQuoteAmount.toNumber()
    )
  );

  // Sign with protocol wallet and escrow
  distributionTx.feePayer = PROTOCOL_WALLET;
  const { blockhash } = await connection.getLatestBlockhash();
  distributionTx.recentBlockhash = blockhash;
  distributionTx.sign(PROTOCOL_WALLET_KEYPAIR, escrowKeypair);

  const distributionSignature = await connection.sendTransaction(distributionTx, { skipPreflight: false });
  await connection.confirmTransaction(distributionSignature, 'confirmed');

  8. Update database:
    - bookbuildings.status = 'launched'
    - bookbuildings.clearing_fdv = clearing_fdv
    - bookbuildings.launched_at = NOW()
    - bookbuildings.amm_pool_address = pool address
  9. Initialize vesting claims:
    - Create bookbuilding_claims for qualifying bids
    - Set vesting_start_at = NOW(), tokens_allocated
  10. Release lock in finally block
  11. Return:
    - AMM pool address
    - Transaction signatures
    - Launch summary

  2.6 Claims Endpoints

  Handle two scenarios for claim endpoints:

  GET /:tokenAddress/claims/:wallet

  Response should include:
  {
    vestingClaim: {
      // Vesting claim data for qualifying bids
      tokensAllocated: string,
      tokensClaimed: string,
      tokensVested: string,
      vestingStartAt: string,
      vestingDuration: number,
      // ...
    } | null,
    refundClaim: {
      // Refund data for non-qualifying bids
      refundable: boolean,
      refundAmount: string,      // Total bid amount to refund
      refundClaimed: boolean,
      bidIds: number[]           // List of non-qualifying bid IDs
    } | null
  }

  POST /:tokenAddress/claims/prepare
  Body: {
    wallet: string,
    claimType: 'vesting' | 'refund'  // Specify claim type
  }

  For vesting claims (qualifying bids):
  - Use vesting logic
  - Calculate vested amount based on time elapsed
  - Create transfer from escrow to user
  - User pays for creating their token ATA if needed

  For refund claims (non-qualifying bids):
  - Aggregate all non-qualifying, non-withdrawn bids for user
  - Calculate total refund amount
  - Create transfer from escrow to user for full bid_amount
  - Mark all refunded bids as claimed
  - User pays for creating their contribution token ATA if needed

  POST /:tokenAddress/claims/confirm
  Body: {
    wallet: string,
    transactionSignature: string,
    claimType: 'vesting' | 'refund'
  }

  - Verify transaction on-chain
  - Update bookbuilding_bids or bookbuilding_claims accordingly
  - For refunds: Mark all non-qualifying bids as claimed

  ---
  Phase 3: UI Component Updates

  3.1 LaunchContent.tsx

  Add bookbuilding option to launch form:

  Add inputs when bookbuilding enabled:
  {formData.bookbuilding && (
    <>
      {/* Contribution Token */}
      <div className="text-[14px] mt-0.5">
        <span className="text-gray-300">Contribution Token CA: </span>
        <input
          name="contributionTokenMint"
          placeholder="Enter token mint address (e.g., USDC)"
          // validation
        />
      </div>

      {/* Vesting Duration */}
      <div className="text-[14px] mt-0.5">
        <span className="text-gray-300">Vesting Duration (days): </span>
        <input
          type="number"
          name="vestingDurationDays"
          placeholder="14"
          // convert to seconds on submit
        />
      </div>

      {/* Vesting Cliff */}
      <div className="text-[14px] mt-0.5">
        <span className="text-gray-300">Vesting Cliff (days): </span>
        <input
          type="number"
          name="vestingCliffDays"
          placeholder="0"
          // convert to seconds on submit
        />
      </div>
    </>
  )}

  Update API call:
  body: JSON.stringify({
    name: formData.name,
    symbol: formData.ticker,
    uri: metadataData.url,
    creatorWallet: externalWallet.toString(),
    contributionTokenMint: formData.contributionTokenMint,
    // decimals will be fetched from chain by backend
    vestingDurationSeconds: formData.vestingDurationDays * 86400,
    vestingCliffSeconds: formData.vestingCliffDays * 86400,
    caEnding: formData.caEnding || undefined,
  })

  3.2 BookbuildingContent.tsx

  New component - two states:

  State 1: Pending (Bidding Open)

  Show:
  - Bookbuilding info (token name, symbol, contribution token)
  - Bid submission form
  - User's existing bids with withdraw buttons
  - Total stats (bids count, total volume)

  New component sections:
  {bookbuilding.status === 'pending' && (
    <>
      <BidSubmissionForm
        bookbuilding={bookbuilding}
        onBidSubmitted={refetch}
      />

      <UserBidsList
        bids={userBids}
        onWithdraw={handleWithdraw}
      />

      {isCreator && (
        <button onClick={() => setShowLaunchPreview(true)}>
          Choose Launch Valuation
        </button>
      )}
    </>
  )}

  State 2: Launched

  Show:
  - AMM pool link
  - Vesting interface (qualifying bidders)
  - Refund interface (non-qualifying bidders)

  3.3 BidSubmissionForm Component (NEW)

  File: ui/components/BidSubmissionForm.tsx

  Features:
  - Input: bid amount
  - Input: max acceptable FDV
  - Button: Submit Bid
  - Creates token transfer to escrow
  - Calls POST /bookbuilding/{token}/bids
  - Note: Users can submit multiple bids (for different price points)
  - Note: Bid modification NOT allowed - must withdraw and resubmit

  <div>
    <input
      type="number"
      placeholder="Bid Amount (USDC)"
      value={bidAmount}
      onChange={...}
    />

    <input
      type="number"
      placeholder="Max Acceptable FDV (USDC)"
      value={maxFdv}
      onChange={...}
    />

    <button onClick={handleSubmitBid}>
      Submit Bid
    </button>

    <p className="text-sm text-gray-400">
      You can submit multiple bids. To change a bid, withdraw it and submit a new one.
    </p>
  </div>

  Submit flow:
  1. Create SPL token transfer (user → escrow)
  2. Include ATA creation if user doesn't have contribution token account
  3. User signs with Privy (pays for transaction + ATA creation if needed)
  4. Submit transaction to Solana
  5. Call backend with signature + maxFdv
  6. Backend verifies and records

  3.4 LaunchPreviewModal Component (NEW)

  File: ui/components/LaunchPreviewModal.tsx

  Features:
  - Input: clearing FDV (with debounced API calls)
  - Real-time calculated display
  - Confirm button

  export function LaunchPreviewModal({ bookbuilding, onClose, onConfirm }) {
    const [fdv, setFdv] = useState('');
    const { data: preview, isLoading } = useSWR(
      fdv ? `/bookbuilding/${bookbuilding.token_address}/preview?fdv=${fdv}` : null,
      fetcher,
      { refreshInterval: 0 }
    );

    return (
      <Modal>
        <h2>Choose Launch Valuation</h2>

        <input
          type="number"
          placeholder="Clearing FDV (in contribution token)"
          value={fdv}
          onChange={(e) => setFdv(e.target.value)}
        />

        {preview && (
          <div>
            <h3>Launch Parameters</h3>
            <p>Price per token: {preview.pricePerToken}</p>
            <p>Total raised: {preview.totalRaised}</p>
            <p>Tokens sold: {preview.tokensSold}</p>

            <h4>Liquidity (AMM)</h4>
            <p>Dollars: {preview.liquidity.dollars}</p>
            <p>Tokens: {preview.liquidity.tokens}</p>

            <h4>Treasury</h4>
            <p>Dollars: {preview.treasury.dollars}</p>
            <p>Tokens: {preview.treasury.tokens}</p>

            <h4>Bids</h4>
            <p>Qualifying: {preview.qualifyingBidsCount}</p>
            <p>Non-qualifying: {preview.totalBidsCount - preview.qualifyingBidsCount}</p>

            {preview.totalRaised === '0' && (
              <p className="text-red-400">
                Error: No qualifying bids at this FDV
              </p>
            )}

            <button
              onClick={() => onConfirm(fdv)}
              disabled={preview.totalRaised === '0'}
            >
              Confirm Launch
            </button>
          </div>
        )}
      </Modal>
    );
  }

  3.5 UserBidsList Component (NEW)

  File: ui/components/UserBidsList.tsx

  Shows:
  - All user's bids for this bookbuilding
  - Each bid shows: amount, max FDV, status (pending/withdrawn)
  - Withdraw button for each non-withdrawn bid (if bookbuilding status = pending)
  - Helper text: "Withdraw a bid to change your max FDV or bid amount"

  3.6 Bookbuilding Lock Management

  File: ui/lib/bookbuildingLocks.ts

  /**
   * Lock management for bookbuilding operations
   * Prevents race conditions between withdrawals and launch
   */

  const bookbuildingLocks = new Map<string, Promise<void>>();

  /**
   * Acquire a bookbuilding lock for a specific token
   * Prevents concurrent modifications to the same bookbuilding
   */
  export async function acquireBookbuildingLock(
    tokenAddress: string
  ): Promise<() => void> {
    const key = tokenAddress.toLowerCase();

    // Wait for any existing lock to be released
    while (bookbuildingLocks.has(key)) {
      await bookbuildingLocks.get(key);
    }

    // Create a new lock
    let releaseLock: () => void;
    const lockPromise = new Promise<void>((resolve) => {
      releaseLock = resolve;
    });

    bookbuildingLocks.set(key, lockPromise);

    // Return the release function
    return () => {
      bookbuildingLocks.delete(key);
      releaseLock!();
    };
  }

  Usage in endpoints:

  // In withdraw endpoint
  const releaseLock = await acquireBookbuildingLock(tokenAddress);
  try {
    // Perform withdrawal logic
  } finally {
    releaseLock();
  }

  // In launch endpoint
  const releaseLock = await acquireBookbuildingLock(tokenAddress);
  try {
    // Perform launch logic
  } finally {
    releaseLock();
  }

  ---
  Phase 4: Meteora CP-AMM Integration

  4.1 SDK Already Installed

  @meteora-ag/cp-amm-sdk v1.1.5 is already in package.json
  @meteora-ag/dlmm v1.7.6 has been installed

  Note: Use CP-AMM (constant product) for bookbuilding pools, not DLMM.
  CP-AMM provides full-range liquidity which is simpler and more appropriate.

  4.2 Create Pool Service

  File: ui/lib/meteoraCpAmmService.ts

  import { CpAmm, deriveCustomizablePoolAddress, InitializeCustomizeablePoolParams, PoolFeesParams } from "@meteora-ag/cp-amm-sdk";
  import { Connection, PublicKey, Keypair, Transaction } from "@solana/web3.js";
  import BN from "bn.js";
  import { TOKEN_PROGRAM_ID, TOKEN_2022_PROGRAM_ID, getMint } from "@solana/spl-token";

  /**
   * Creates a customizable CP-AMM pool with liquidity
   * Returns the transaction and pool address
   */
  export async function createBookbuildingCPAMMPool(params: {
    connection: Connection;
    baseMint: PublicKey;        // New token
    quoteMint: PublicKey;       // Contribution token (e.g., USDC)
    baseAmount: BN;             // 0.25T tokens
    quoteAmount: BN;            // 0.25R contribution tokens
    creator: PublicKey;         // Main protocol address (treasury)
    payer: PublicKey;           // Escrow (will pay for tx)
    escrowKeypair: Keypair;     // For signing
  }): Promise<{
    tx: Transaction;
    pool: PublicKey;
    position: PublicKey;
  }> {
    const {
      connection,
      baseMint,
      quoteMint,
      baseAmount,
      quoteAmount,
      creator,
      payer,
      escrowKeypair
    } = params;

    // Initialize CP-AMM SDK
    const cpAmm = new CpAmm(connection);

    // Generate position NFT keypair
    const positionNftKeypair = Keypair.generate();

    // Get token programs (check if Token2022)
    const baseMintInfo = await getMint(connection, baseMint);
    const quoteMintInfo = await getMint(connection, quoteMint);

    const baseTokenProgram = baseMintInfo.tlvData.length > 0 ? TOKEN_2022_PROGRAM_ID : TOKEN_PROGRAM_ID;
    const quoteTokenProgram = quoteMintInfo.tlvData.length > 0 ? TOKEN_2022_PROGRAM_ID : TOKEN_PROGRAM_ID;

    // Calculate sqrt prices for full-range liquidity
    // For constant product: P = quoteAmount / baseAmount
    // We want full range, so use MIN and MAX sqrt prices
    const MIN_SQRT_PRICE = new BN("4295048016"); // sqrt(2^-64) in Q64
    const MAX_SQRT_PRICE = new BN("79226673515401279992447579055"); // sqrt(2^64) in Q64

    // Calculate initial sqrt price from token amounts
    // sqrt(P) = sqrt(quoteAmount / baseAmount) in Q64 format
    const { initSqrtPrice, liquidityDelta } = cpAmm.preparePoolCreationParams({
      tokenAAmount: baseAmount,
      tokenBAmount: quoteAmount,
      minSqrtPrice: MIN_SQRT_PRICE,
      maxSqrtPrice: MAX_SQRT_PRICE,
      tokenAInfo: baseMintInfo.tlvData.length > 0 ? {
        mint: baseMintInfo,
        currentEpoch: await connection.getEpochInfo().then(e => e.epoch)
      } : undefined,
      tokenBInfo: quoteMintInfo.tlvData.length > 0 ? {
        mint: quoteMintInfo,
        currentEpoch: await connection.getEpochInfo().then(e => e.epoch)
      } : undefined,
    });

    // Define pool fees (0.3% swap fee for bookbuilding pools)
    // Using static fee with no dynamic fee adjustments
    const poolFees: PoolFeesParams = {
      baseFee: {
        cliffFeeNumerator: new BN(300),  // 0.3% base fee (300 basis points)
        numberOfPeriod: 0,
        periodFrequency: new BN(0),
        reductionFactor: new BN(0),
        feeSchedulerMode: 0  // Static fee mode
      },
      padding: [0, 0, 0, 0, 0, 0],  // 6 padding bytes
      dynamicFee: null  // No dynamic fee
    };

    // Create customizable pool with initial liquidity
    const poolParams: InitializeCustomizeablePoolParams = {
      payer: payer,
      creator: creator,           // Treasury/protocol address owns the pool
      positionNft: positionNftKeypair.publicKey,
      tokenAMint: baseMint,       // New token
      tokenBMint: quoteMint,      // Contribution token
      tokenAAmount: baseAmount,
      tokenBAmount: quoteAmount,
      sqrtMinPrice: MIN_SQRT_PRICE,
      sqrtMaxPrice: MAX_SQRT_PRICE,
      liquidityDelta: liquidityDelta,
      initSqrtPrice: initSqrtPrice,
      poolFees: poolFees,
      hasAlphaVault: false,
      activationType: 0,          // Slot-based activation
      collectFeeMode: 0,          // Default fee collection
      activationPoint: null,      // Activate immediately
      tokenAProgram: baseTokenProgram,
      tokenBProgram: quoteTokenProgram,
      isLockLiquidity: false      // Treasury can withdraw if needed
    };

    // Create pool transaction
    const { tx, pool, position } = await cpAmm.createCustomPool(poolParams);

    // Sign with escrow and position NFT keypairs
    tx.partialSign(escrowKeypair, positionNftKeypair);

    return { tx, pool, position };
  }

  /**
   * Derives the pool address for a customizable pool
   * Note: Requires config address - use deriveCustomizablePoolAddress
   */
  export function getPoolAddress(
    config: PublicKey,
    tokenAMint: PublicKey,
    tokenBMint: PublicKey
  ): PublicKey {
    return deriveCustomizablePoolAddress(config, tokenAMint, tokenBMint);
  }

  4.3 Update Launch Handler

  File: ui/routes/bookbuilding.ts (in launch endpoint)

  Implementation:
  import { createBookbuildingCPAMMPool } from '@/lib/meteoraCpAmmService';
  import { createMintToInstruction, createTransferInstruction, getAssociatedTokenAddress } from '@solana/spl-token';

  // After calculating R and T and validating
  const TREASURY_ADDRESS = new PublicKey(process.env.TREASURY_WALLET!); // Hq7Xh37tT4sesD6wA4DphYfxeMJRhhFWS3KVUSSGjqzc

  // Calculate amounts for AMM pool (25% each)
  const baseAmountForPool = T.muln(25).divn(100);  // 0.25T
  const quoteAmountForPool = R.muln(25).divn(100); // 0.25R

  // Step 1: Transfer 0.25T from protocol to escrow (see Phase 2.5 step 6)
  // [transfer code already shown above]

  // Step 2: Create CP-AMM pool (separate transaction)
  const { tx: createPoolTx, pool: poolAddress, position: positionAddress } = await createBookbuildingCPAMMPool({
    connection,
    baseMint: new PublicKey(baseMint),
    quoteMint: new PublicKey(bookbuilding.contribution_token_mint),
    baseAmount: baseAmountForPool,
    quoteAmount: quoteAmountForPool,
    creator: TREASURY_ADDRESS,  // Pool owner
    payer: escrowKeypair.publicKey,
    escrowKeypair: escrowKeypair
  });

  // Send pool creation transaction
  const poolCreationSignature = await connection.sendTransaction(createPoolTx, { skipPreflight: false });
  await connection.confirmTransaction(poolCreationSignature, 'confirmed');

  // Note: Position NFT is automatically created and held by treasury (creator)
  // No need to store position address in database

  // Step 3: Distribution transaction - see Phase 2.5 step 7 for implementation details

  ---
  Phase 6: Precision & Math Library

  6.1 Use BN for All Calculations

  File: ui/lib/bookbuildingMath.ts

  import BN from 'bn.js';

  export function calculateTokensSold(
    totalRaised: BN,
    tokenSupply: BN,
    clearingFdv: BN
  ): BN {
    // T = (R × S) / V (where S = token supply)
    // To avoid overflow: (R / V) × S
    return totalRaised.mul(tokenSupply).div(clearingFdv);
  }

  export function calculateProRataAllocation(
    userBid: BN,
    totalRaised: BN,
    tokensSold: BN
  ): BN {
    // allocation = (userBid / totalRaised) × T
    return userBid.mul(tokensSold).div(totalRaised);
  }

  export function calculateLiquidityAmounts(tokensSold: BN) {
    // 0.25T
    return tokensSold.muln(25).divn(100);
  }

  export function calculateTreasuryTokens(
    protocolBalance: BN,
    tokensSold: BN
  ): BN {
    // Protocol balance - 1.25T
    const sold125 = tokensSold.muln(125).divn(100);
    return protocolBalance.sub(sold125);
  }

  6.2 Rounding Strategy

  For pro-rata allocations:
  export function allocateTokensToUsers(
    bids: Bid[],
    totalRaised: BN,
    tokensSold: BN
  ): Map<string, BN> {
    const allocations = new Map();
    let totalAllocated = new BN(0);

    // Calculate each user's share
    for (const bid of bids) {
      const allocation = calculateProRataAllocation(
        new BN(bid.bid_amount),
        totalRaised,
        tokensSold
      );
      allocations.set(bid.id, allocation);
      totalAllocated = totalAllocated.add(allocation);
    }

    // Give remainder to largest bidder to ensure sum = tokensSold
    const remainder = tokensSold.sub(totalAllocated);
    if (!remainder.isZero() && bids.length > 0) {
      // Find the largest bid
      const largestBid = bids.reduce((max, bid) =>
        new BN(bid.bid_amount).gt(new BN(max.bid_amount)) ? bid : max
      );
      const largestAllocation = allocations.get(largestBid.id)!;
      allocations.set(largestBid.id, largestAllocation.add(remainder));
    }

    return allocations;
  }

  ---
  Phase 7: Error Handling & Validation

  7.1 Validation Rules

  Bookbuilding creation:
  - contributionTokenMint: Valid Solana address
  - vestingDurationSeconds: > 0
  - vestingCliffSeconds: >= 0 and < vestingDurationSeconds

  Bid submission:
  - bid_amount: > 0
  - max_fdv: > 0
  - Status must be 'pending'
  - Transaction must be valid and recent

  Launch:
  - Status must be 'pending'
  - Only creator can launch
  - R must be > 0 (at least one qualifying bid)
  - clearing_fdv must be > 0
  - clearing_fdv >= 1.25 × R (ensures treasury doesn't go negative)
  - Protocol wallet balance must be >= 1.25T (on-chain verification)
  - Escrow balance must match sum of non-withdrawn qualifying bids (on-chain verification)

  7.2 Error Messages

  const ERRORS = {
    BOOKBUILDING_NOT_PENDING: 'Bookbuilding has already launched',
    NO_QUALIFYING_BIDS: 'No bids qualify at this FDV. Choose a lower valuation.',
    CLEARING_FDV_TOO_LOW: 'Clearing FDV too low. Minimum FDV: [calculated minimum]',
    ALREADY_LAUNCHED: 'Bookbuilding already launched',
    NOT_CREATOR: 'Only bookbuilding creator can launch',
    INVALID_BID: 'Invalid bid amount or max FDV',
    WITHDRAWAL_FAILED: 'Cannot withdraw after bookbuilding launches',
    ALREADY_WITHDRAWN: 'Bid already withdrawn',
    INVALID_CONTRIBUTION_TOKEN: 'Invalid or non-existent contribution token mint address',
    INSUFFICIENT_PROTOCOL_BALANCE: 'Insufficient protocol wallet balance. Transfer more tokens to protocol wallet.',
    ESCROW_BALANCE_MISMATCH: 'Escrow balance does not match expected bid total - possible withdrawn or pending bids',
    LOCK_ACQUISITION_FAILED: 'Failed to acquire lock - operation in progress',
    LAUNCH_IN_PROGRESS: 'Launch already in progress for this bookbuilding'
  };

  ---
  Phase 8: Testing Strategy

  8.1 Unit Tests

  Test bookbuildingMath.ts:
  - Edge cases: R=1, V=tokenSupply (T should be 1)
  - Large numbers: R=1M, V=10M with various token supplies
  - Rounding: ensure sum of allocations = T
  - Test with different token supplies (1M, 10M, 1B, etc.)

  8.2 Integration Tests

  Test bid flow:
  1. Create bookbuilding
  2. Submit multiple bids with varying max_fdv
  3. Withdraw some bids
  4. Launch with clearing_fdv
  5. Verify allocations
  6. Test claims (qualifying vs non-qualifying)

  8.3 Manual Testing Checklist

  - Create bookbuilding with custom contribution token (verify decimals fetched correctly)
  - Submit bid (verify on-chain + DB)
  - Withdraw bid (verify refund)
  - Preview with different FDVs (check calculations)
  - Try to launch with FDV < 1.25 × R (should error with minimum FDV message)
  - Try to launch with insufficient protocol balance (should error)
  - Launch with valid FDV (verify AMM creation, token distribution, transfers)
  - Verify treasury receives correct amount: (protocol balance - 1.25T)
  - Verify escrow receives T tokens for vesting
  - Verify AMM pool receives 0.25T tokens
  - Claim vested tokens (qualifying bid)
  - Claim refund (non-qualifying bid)
  - Try to launch with R=0 (should error)
  - Try to withdraw after launch (should error)
  - Test repeated bookbuilding: launch, transfer more tokens to protocol, launch again

  ---
  Implementation Order

  Week 1: Backend Foundation
  1. Token creation script (create-bookbuilding-token.ts) - protocol only
  2. Database migration script
  3. Create bookbuilding creation endpoint (accepts existing token address)
  4. Bid submission endpoint
  5. Withdrawal endpoint
  6. Preview calculations endpoint

  Week 2: Launch Mechanism
  7. Meteora CP-AMM SDK integration
  8. Math library with BN
  9. Launch endpoint (transfer tokens, create pool, distribute)
  10. Lock management (bookbuildingLocks.ts)
  11. Vesting initialization

  Week 3: UI Components
  11. Update LaunchContent form
  12. BidSubmissionForm component
  13. LaunchPreviewModal component
  14. Create BookbuildingContent component
  15. UserBidsList component

  Week 4: Claims & Testing
  16. Claims for qualifying/non-qualifying
  17. Integration testing
  18. Manual testing
  19. Bug fixes
  20. Deploy

  ---
  Files to Create Summary

  New Files:

  - ui/scripts/create-bookbuilding-token.ts (protocol-only script for token creation)
  - ui/scripts/migrations/003_bookbuilding.sql
  - ui/lib/bookbuildingMath.ts
  - ui/lib/meteoraCpAmmService.ts
  - ui/lib/bookbuildingLocks.ts (lock management)
  - ui/components/BidSubmissionForm.tsx
  - ui/components/LaunchPreviewModal.tsx
  - ui/components/UserBidsList.tsx
  - ui/components/BookbuildingContent.tsx
  - ui/lib/db/bookbuildings.ts (new functions)
  - ui/app/api/bookbuilding/route.ts (create endpoint)
  - ui/routes/bookbuilding.ts (ALL bid/launch/claim endpoints)

  Modified Files:

  - ui/lib/db.ts (add bookbuilding schema references)
  - ui/lib/db/types.ts (add bookbuilding interfaces)
  - ui/components/LaunchContent.tsx (add bookbuilding option)

  Environment Variables Required:

  - TREASURY_WALLET: Main protocol treasury address (e.g., Hq7Xh37tT4sesD6wA4DphYfxeMJRhhFWS3KVUSSGjqzc)
  - PROTOCOL_WALLET: Protocol wallet address that holds all tokens
  - PROTOCOL_WALLET_PRIVATE_KEY: Private key for protocol wallet (for signing transfers)
  - PROTOCOL_MINT_AUTHORITY_PRIVATE_KEY: Private key for creating tokens (used in create-bookbuilding-token.ts)
  - RPC_URL: Solana RPC endpoint
  - DB_URL: PostgreSQL database connection string

  ---
  Risk Areas

  1. ✓ RESOLVED: Meteora CP-AMM SDK - API verified, see Phase 4.2 for implementation
  2. Precision errors - Must test math extensively with BN library for large numbers
  3. ✓ RESOLVED: Treasury underflow - Validation added: clearing_fdv >= 1.25 × R
  4. ✓ RESOLVED: Contribution token validation - Uses getMint() to fetch decimals
  5. ✓ RESOLVED: Transaction separation - Pool creation and distribution are separate transactions
     - Pool creation handles 0.25T + 0.25R automatically
     - Distribution transaction mints remaining tokens and transfers funds
  6. ✓ RESOLVED: Fee calculation precision - Uses baseFee.cliffFeeNumerator = 300
     - Static fee mode (feeSchedulerMode = 0)
     - No dynamic fee adjustments (dynamicFee = null)
  7. Token2022 compatibility - Code handles both TOKEN_PROGRAM_ID and TOKEN_2022_PROGRAM_ID
     - Must test with Token2022 contribution tokens (e.g., USDC on Token2022)
  8. ✓ RESOLVED: Rounding dust - Pro-rata allocation gives remainder to largest bidder
     - More fair than giving to first bidder
     - Largest contributor gets minor rounding benefit
  9. ✓ RESOLVED: Race conditions - Lock management implemented in bookbuildingLocks.ts
     - Prevents concurrent withdrawals during launch
     - Prevents multiple simultaneous launches
  10. ✓ RESOLVED: Escrow balance verification - On-chain verification added to launch
     - Compares escrow balance with sum of non-withdrawn qualifying bids
     - Prevents fake bid attacks and race condition exploits

  ---

● Executive Summary

  Key Changes

  Database:
  - New tables: bookbuildings, bookbuilding_bids, bookbuilding_claims
  - Include contribution token mint + decimals (fetched from chain), vesting params, clearing FDV
  - Track max_fdv, qualifying status, tokens_allocated for bids
  - Status: 'pending' | 'launched'

  Backend (6 new endpoints + lock management):
  1. Create bookbuilding - accept contribution token (fetch decimals on-chain) + vesting params
  2. Submit bid - verify transfer + record max_fdv
  3. Withdraw bid - refund before launch (not after), with locking to prevent race conditions
  4. Preview - real-time calculations for any FDV showing qualifying bids (filters withdrawn bids)
  5. Launch - validates clearing_fdv >= 1.25×R, verifies escrow balance on-chain, creates pool separately, distribution transaction, with locking
  6. Claims - handle vested tokens (qualifying) or refunds (non-qualifying)

  Lock Management:
  - bookbuildingLocks.ts implements lock acquisition/release
  - Prevents race between withdrawals and launch
  - Ensures atomicity of critical operations

  UI:
  - LaunchContent: Add bookbuilding option with contribution token + vesting inputs (no decimals input)
  - BookbuildingContent: New component with 2 states (pending/bidding, launched)
  - New components: BidSubmissionForm, LaunchPreviewModal, UserBidsList

  Token Distribution:
  - T tokens → bookbuilding participants (vested in escrow)
  - 0.25T → AMM pool
  - (Protocol balance - 1.25T) → treasury

  Fund Distribution:
  - 0.25R → AMM pool
  - 0.75R → treasury

  Critical Requirements:
  - Token must be created BEFORE bookbuilding (using create-bookbuilding-token.ts script)
  - Founder transfers desired token amount to protocol wallet before launch
  - NO minting during bookbuilding launch - only transfers
  - Supports repeated bookbuildings: founder can run multiple fundraises with same token
  - At launch, protocol wallet must have >= 1.25T tokens
  - Treasury receives: (protocol balance) - 1.25T tokens
  - Contribution token decimals fetched from chain (not user input)
  - Clearing FDV validation: must be >= 1.25×R (prevents treasury underflow)
  - Step 1: Transfer 0.25T from protocol to escrow (for pool)
  - Step 2: Pool creation (with 0.25T + 0.25R) in SEPARATE transaction
  - Step 3: Distribution transaction transfers tokens (T to escrow, rest to treasury) and 0.75R to treasury
  - Escrow balance verified on-chain before launch (prevents fake bids and race conditions)
  - Lock management prevents concurrent withdrawals during launch

  Math:
  - Use BN library for all calculations to avoid overflow/precision errors
  - Handle rounding by giving remainder to largest bidder (not first)
  - Filter withdrawn bids in all calculations (!withdrawn check)

  ---

  Answers to Key Questions

  Q1: Meteora CP-AMM SDK Integration
  ✓ ANSWERED - SDK is already installed (@meteora-ag/cp-amm-sdk v1.1.5)
  - Use CpAmm class with createCustomPool() method
  - Returns Transaction that creates pool with initial liquidity
  - Pool owner set to treasury/protocol address
  - Pool fees use PoolFeesParams structure with baseFee.cliffFeeNumerator: 300 (0.3%)
  - Returns pool address and position NFT address
  - Position NFT held by treasury, NOT stored in database
  - deriveCustomizablePoolAddress() requires config parameter
  - See Phase 4.2 for complete implementation

  Q2: AMM Pool Ownership
  ✓ ANSWERED - Pool owner = main protocol address (treasury)
  - Treasury has full control over pool
  - Can withdraw liquidity if needed
  - Can adjust fees/settings
  - Set via creator parameter in InitializeCustomizeablePoolParams
  - Position NFT automatically held by creator (treasury)

  Q3: Non-Qualifying Bid Refunds
  ✓ ANSWERED - Manual claim by user after launch
  - GET /:tokenAddress/claims/:wallet returns refund info
  - POST /:tokenAddress/claims/prepare with claimType='refund'
  - Escrow creates transfer transaction for full bid_amount
  - User signs and submits (user pays for ATA creation)
  - POST /:tokenAddress/claims/confirm marks bids as claimed
  - See Phase 2.6 for complete API spec

  Q4: Implementation Approach
  - Entirely new system separate from existing presale
  - Suggested order: Database → Backend → Meteora Integration → UI → Testing

  Additional Design Decisions

  ✓ Pool Swap Fee: 0.3% using baseFee.cliffFeeNumerator = 300, static fee mode
  ✓ PoolFeesParams: Uses baseFee structure with padding and null dynamicFee
  ✓ ATA Creation: Paid by users in all transactions (bids, withdrawals, claims)
  ✓ Position NFT: Held by treasury address, not tracked in database
  ✓ Minimum Bid: No minimum bid amount validation
  ✓ Bid Modification: NOT allowed - users must withdraw and resubmit for changes
  ✓ Multiple Bids: Allowed intentionally (enables different price points per user)